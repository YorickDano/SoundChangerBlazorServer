@page "/visualizer/{SetHashCode:int}"

@inject StateContainer StateContainer;
@inject IJSRuntime JS;

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Visualizer</title>
    <link href="~/css/VisualizerStyles.css" type="text/css" />
</head>
<body>
    <div class="container">
        <h1>Audio Visualizer</h1>
        <p class="subtitle">Experience your audio with a larger, more immersive visualization</p>

        <div class="audio-container">
            <audio id="audioPlayer" volume="0.3" controls src="\@_audioFile!.AudioPath">
            </audio>
        </div>

        <div class="controls">
            <div class="control-group">
                <div class="control-title">
                    <span>Tempo</span>
                    <span class="control-value" id="tempo-value">1.0x</span>
                </div>
                <input type="range" id="tempo" min="0.1" max="2.0" step="0.01" value="1.0" />
            </div>
            <div class="control-group">
                <div class="control-title">
                    <span>Pitch</span>
                    <span class="control-value" id="pitch-value">1.0x</span>
                </div>
                <input type="range" id="pitch" min="0.1" max="2.0" step="0.01" value="1.0" />
            </div>

            <div class="control-group">
                <div class="control-title">
                    <span>Volume</span>
                    <span class="control-value" id="volume-value">0.3</span>
                </div>
                <input type="range" id="volume" min="0" max="5" step="0.01" value="0.3" />
            </div>

            <div class="control-group">
                <div class="control-title">
                    <span>Bass Boost</span>
                    <span class="control-value" id="bass-value">1.0</span>
                </div>
                <input type="range" id="bass" min="0.01" max="2.0" step="0.01" value="1.0" />
            </div>
        </div>

        <div class="visualizer-container">
            <div class="visualizer-options">
                <button class="vis-btn active" data-mode="bars">Bars</button>
                <button class="vis-btn" data-mode="waveform">Waveform</button>
                <button class="vis-btn" data-mode="circle">Circle</button>
                <button class="vis-btn" data-mode="particles">Particles</button>
            </div>

            <div id="visualizerBox" class="visualizer">
                <canvas id="visualizer"></canvas>
            </div>

            <p class="visualizer-info">Current visualization: <span id="vis-mode">Bars</span></p>
        </div>

        <button class="btn" id="fullscreenBtn">Enter Fullscreen Visualizer</button>
    </div>
    <script>
        async function initApp() {
            // Initialize variables
            let audioContext;
            let soundTouch;
            let analyzer;
            let source;
            let gainNode;
            let bassBoost;
            let isPlaying = false;
            let visualizationMode = 'bars';
            let isFullscreen = false;


            // Get elements
            const audioElement = document.getElementById('audioPlayer');
            audioElement.volume = 0.3;
            const visualizer = document.getElementById('visualizer');
            const visualizerBox = document.getElementById('visualizerBox');
            const canvasCtx = visualizer.getContext('2d');
            const tempoControl = document.getElementById('tempo');
            const tempoValue = document.getElementById('tempo-value');
            const pitchControl = document.getElementById('pitch');
            const pitchValue = document.getElementById('pitch-value');
            const volumeControl = document.getElementById('volume');
            const volumeValue = document.getElementById('volume-value');
            const bassControl = document.getElementById('bass');
            const bassValue = document.getElementById('bass-value');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const visModeElement = document.getElementById('vis-mode');
            const visButtons = document.querySelectorAll('.vis-btn');

            // Set canvas dimensions
            function resizeCanvas() {
                visualizer.width = visualizer.offsetWidth;
                visualizer.height = visualizer.offsetHeight;
            }

            resizeCanvas();


            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            source = audioContext.createMediaElementSource(audioElement);
            // Create gain node for volume control
            gainNode = audioContext.createGain();
            await audioContext.audioWorklet.addModule('./js/soundtouch-worklet.js');
            soundTouch = new AudioWorkletNode(audioContext, 'soundtouch-processor');
            // Create biquad filter for bass boost
            bassBoost = audioContext.createBiquadFilter();
            bassBoost.type = 'lowshelf';
            bassBoost.frequency.setValueAtTime(100, audioContext.currentTime);
            source.connect(soundTouch);
            soundTouch.connect(bassBoost);
            bassBoost.connect(gainNode);
            gainNode.connect(audioContext.destination);

            setupVisualizer();

            function setupVisualizer() {
                if (analyzer) {
                    analyzer.disconnect();
                }

                analyzer = audioContext.createAnalyser();
                analyzer.fftSize = 512;
                gainNode.connect(analyzer);

                visualize();
            }

            function visualize() {
                if (!analyzer) return;

                const bufferLength = analyzer.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                const waveformArray = new Uint8Array(bufferLength);

                function draw() {
                    requestAnimationFrame(draw);

                    canvasCtx.fillStyle = 'rgb(0, 0, 0)';
                    canvasCtx.fillRect(0, 0, visualizer.width, visualizer.height);

                    if (visualizationMode === 'waveform') {
                        analyzer.getByteTimeDomainData(waveformArray);
                    } else {
                        analyzer.getByteFrequencyData(dataArray);
                    }

                    // Draw based on selected mode
                    switch (visualizationMode) {
                        case 'bars':
                            drawBars(dataArray, bufferLength);
                            break;
                        case 'waveform':
                            drawWaveform(waveformArray, bufferLength);
                            break;
                        case 'circle':
                            drawCircle(dataArray, bufferLength);
                            break;
                        case 'particles':
                            drawParticles(dataArray, bufferLength);
                            break;
                    }
                }

                draw();
            }

            function drawBars(dataArray, bufferLength) {
                const barWidth = (visualizer.width / bufferLength) * 2.5;
                let barHeight;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    barHeight = dataArray[i] * (visualizer.height / 256);

                    const gradient = canvasCtx.createLinearGradient(0, visualizer.height - barHeight, 0, visualizer.height);
                    gradient.addColorStop(0, `hsl(${i / bufferLength * 360}, 100%, 60%)`);
                    gradient.addColorStop(1, `hsl(${i / bufferLength * 360}, 100%, 20%)`);

                    canvasCtx.fillStyle = gradient;
                    canvasCtx.fillRect(x, visualizer.height - barHeight, barWidth, barHeight);

                    x += barWidth + 1;
                }
            }

            function drawWaveform(dataArray, bufferLength) {
                canvasCtx.lineWidth = 3;
                canvasCtx.strokeStyle = '#fdbb2d';
                canvasCtx.beginPath();

                const sliceWidth = visualizer.width / bufferLength;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * visualizer.height / 2;

                    if (i === 0) {
                        canvasCtx.moveTo(x, y);
                    } else {
                        canvasCtx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                canvasCtx.stroke();
            }

            function drawCircle(dataArray, bufferLength) {
                const centerX = visualizer.width / 2;
                const centerY = visualizer.height / 2;
                const radius = Math.min(centerX, centerY) * 0.6;

                canvasCtx.lineWidth = 2;

                for (let i = 0; i < bufferLength; i++) {
                    const amplitude = dataArray[i] / 256;
                    const angle = (i / bufferLength) * Math.PI * 2;

                    const x1 = centerX + Math.cos(angle) * radius;
                    const y1 = centerY + Math.sin(angle) * radius;
                    const x2 = centerX + Math.cos(angle) * (radius + amplitude * radius);
                    const y2 = centerY + Math.sin(angle) * (radius + amplitude * radius);

                    const hue = i / bufferLength * 360;
                    canvasCtx.strokeStyle = `hsl(${hue}, 100%, 60%)`;

                    canvasCtx.beginPath();
                    canvasCtx.moveTo(x1, y1);
                    canvasCtx.lineTo(x2, y2);
                    canvasCtx.stroke();
                }
            }

            function drawParticles(dataArray, bufferLength) {
                const particleCount = 100;
                const centerX = visualizer.width / 2;
                const centerY = visualizer.height / 2;

                for (let i = 0; i < particleCount; i++) {
                    const amplitude = dataArray[i % bufferLength] / 256;
                    const angle = (i / particleCount) * Math.PI * 2;
                    const distance = amplitude * Math.min(centerX, centerY) * 0.8;

                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    const size = 2 + amplitude * 8;

                    // Color based on frequency
                    const hue = i / particleCount * 360;
                    canvasCtx.fillStyle = `hsla(${hue}, 100%, 60%, ${0.5 + amplitude * 0.5})`;

                    canvasCtx.beginPath();
                    canvasCtx.arc(x, y, size, 0, Math.PI * 2);
                    canvasCtx.fill();
                }
            }

            // Event listeners
            audioElement.addEventListener('play', () => {
                if (!audioContext) {
                    initAudio();
                } else if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                isPlaying = true;
            });

            audioElement.addEventListener('pause', () => {
                isPlaying = false;
            });

            // Tempo control
            tempoControl.addEventListener('input', () => {
                audioElement.playbackRate = tempoControl.value;
                audioElement.preservesPitch = true;
                tempoValue.textContent = tempoControl.value + 'x';
            });

            // Pitch control
            pitchControl.addEventListener('input', () => {
                soundTouch.parameters.get('pitch').value = pitchControl.value;
                pitchValue.textContent = pitchControl.value + 'x';
            });

            // Volume control
            volumeControl.addEventListener('input', () => {
                if (gainNode) {
                    gainNode.gain.value = parseFloat(volumeControl.value);
                }
                volumeValue.textContent = volumeControl.value;
            });

            // Bass control
            bassControl.addEventListener('input', () => {
                if (bassBoost) {
                    var value = parseFloat(bassControl.value);
                    bassBoost.gain.setValueAtTime(
                         value <= 1 ? -(value) : value * 10,
                        audioContext.currentTime
                    );
                }
                bassValue.textContent = bassControl.value;
            });

            // Visualization mode buttons
            visButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    visButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    visualizationMode = btn.dataset.mode;
                    visModeElement.textContent = btn.textContent;
                });
            });

            // Fullscreen button
            fullscreenBtn.addEventListener('click', () => {
                if (!isFullscreen) {
                    visualizer.style.height = '550px';
                    visualizerBox.style.height = '550px';
                    fullscreenBtn.textContent = 'Exit Fullscreen Visualizer';
                } else {
                    visualizer.style.height = '300px';
                    visualizerBox.style.height = '300px';
                    fullscreenBtn.textContent = 'Enter Fullscreen Visualizer';
                }
                isFullscreen = !isFullscreen;
                resizeCanvas();
            });

            // Handle window resize
            window.addEventListener('resize', () => {
                resizeCanvas();
            });
        }
    </script>
</body>
</html>
@code {
    [Parameter]
    public int SetHashCode { get; set; }
    private AudioFile? _audioFile;

    protected override Task OnInitializedAsync()
    {
        _audioFile = (AudioFile)StateContainer.ObjectTunnel[SetHashCode];
        return base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await JS.InvokeVoidAsync("initApp");
    }
}